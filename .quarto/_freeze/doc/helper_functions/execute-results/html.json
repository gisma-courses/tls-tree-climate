{
  "hash": "62c9ebb712f8651b4bb7f194038e85a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Helper Functions for Microclimate Predictor Stack\"\nauthor: \"Chris Reudenbach\"\ndate: \"2025-07-16\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    code-fold: true\n    code-tools: true\nengine: knitr\n---\n\n\n\n\n# Introduction\n\nThis document explains the **custom helper functions** used in the `microclimate_predictor_stack.R` script for preprocessing and analyzing LiDAR data in R. The functions support pixel-level metrics computation, raster template creation, VRT mosaicking, and tree hull extraction.\n\n------------------------------------------------------------------------\n\n# .stdmetrics()\n\n``` r\n#' @title .stdmetrics\n#' @description Berechnet Standardmetriken f√ºr LiDAR Rasterzellen\n.stdmetrics <- function(z, i, ...) {\n  return(list(\n    zmax = max(z, na.rm = TRUE),            # Maximum height\n    zmean = mean(z, na.rm = TRUE),          # Mean height\n    zsd = sd(z, na.rm = TRUE),              # Standard deviation of heights\n    zkurto = moments::kurtosis(z, na.rm = TRUE), # Kurtosis (peakedness of distribution)\n    zskew = moments::skewness(z, na.rm = TRUE),  # Skewness (asymmetry)\n    zq25 = quantile(z, 0.25, na.rm = TRUE), # 25th percentile\n    zq50 = quantile(z, 0.5, na.rm = TRUE),  # Median height\n    zq75 = quantile(z, 0.75, na.rm = TRUE), # 75th percentile\n    zpulse = length(z)                      # Number of returns (pulse count)\n  ))\n}\n```\n\nUsed to derive **standard height-based metrics** from LiDAR returns per raster cell using `pixel_metrics()`.\n\n------------------------------------------------------------------------\n\n# get_vrt_img()\n\n``` r\n#' @title get_vrt_img\n#' @description Creates a VRT from multiple GeoTIFF files in a directory\nget_vrt_img <- function(name, path, pattern) {\n  tifs <- list.files(path = path, pattern = paste0(pattern, \".tif$\"), full.names = TRUE)\n  vrt <- file.path(path, paste0(name, \".vrt\"))\n  if (file.exists(vrt)) file.remove(vrt)\n  gdal_utils(util = \"buildvrt\", source = tifs, destination = vrt)\n  return(vrt)\n}\n```\n\nUsed to dynamically generate a **VRT (virtual raster stack)** from multiple `.tif` files with a matching pattern, e.g. `\"lad_metrics\"`.\n\n------------------------------------------------------------------------\n\n# tree_fn()\n\n``` r\n#' @title tree_fn\n#' @description Creates convex hulls from segmented trees in LAS catalogs\ntree_fn <- function(las, ...) {\n  if (is.empty(las)) return(NULL)                   # Skip if empty\n  las <- filter_poi(las, !is.na(treeID))            # Keep only trees\n  if (npoints(las) == 0) return(NULL)               # Skip if no points\n  dt <- data.table::as.data.table(las@data)\n  dt <- dt[, .(X = mean(X), Y = mean(Y)), by = treeID]  # Mean location per tree\n  points_sf <- st_as_sf(dt, coords = c(\"X\", \"Y\"), crs = sf::st_crs(las))\n  hulls <- st_convex_hull(st_union(points_sf))      # Create unified convex hull\n  return(hulls)\n}\n```\n\nUsed with `catalog_apply()` to derive **convex hull geometries** from segmented tree point clouds.\n\n------------------------------------------------------------------------\n\n# template_raster()\n\n``` r\n#' @title template_raster\n#' @description Creates an empty raster template based on bounding box and resolution\ntemplate_raster <- function(bbox, crs, res = 1.0) {\n  if (inherits(bbox, \"sf\")) bbox <- st_bbox(bbox)\n  r <- terra::rast(xmin = bbox[\"xmin\"], xmax = bbox[\"xmax\"],\n                   ymin = bbox[\"ymin\"], ymax = bbox[\"ymax\"],\n                   resolution = res, crs = crs)\n  return(r)\n}\n```\n\nGenerates a blank `terra::rast` object for rasterizing vector geometries such as LAD polygons or tree hulls.\n\n------------------------------------------------------------------------\n",
    "supporting": [
      "helper_functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}